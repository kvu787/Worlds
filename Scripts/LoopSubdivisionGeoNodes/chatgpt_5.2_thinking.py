# Blender 5.0+ required.
#
# Loop Subdivision (triangle mesh) implemented as a Geometry Nodes modifier
# generated by this script — WITHOUT using Subdivide Mesh / Subdivision Surface nodes.
#
# Matches the math from the original script:
#  - Even vertices:
#      boundary: 0.75*P + 0.125*(boundary neighbor sum) if exactly 2 boundary neighbors else keep P
#      interior: (1 - n*beta)*P + beta*sum(neighbors)
#        beta(n) = (1/n) * (5/8 - (3/8 + 1/4*cos(2π/n))^2)
#  - Odd vertices:
#      boundary edge: midpoint
#      interior edge: 3/8*(v1+v2) + 1/8*(opp1+opp2)
#  - Topology rebuild:
#      each triangle -> 4 triangles via instancing a tiny template mesh and welding
#
# Blender-5-specific improvements:
#  - Uses a Repeat Zone to expose Iterations as a modifier input. (Repeat Zone docs) :contentReference[oaicite:2]{index=2}
#  - Uses Remove Named Attribute for cleanup between iterations. :contentReference[oaicite:3]{index=3}

import bpy
import bmesh
import math


# -----------------------------
# Settings
# -----------------------------
DEFAULT_ITERATIONS = 3
MOD_NAME = "Loop Subdivision (GN math, no Subdivide)"

TEMPLATE_OBJ_NAME = "_LS_Template"
TEMPLATE_SLOT_ATTR = "ls_slot"
MERGE_DISTANCE = 1e-6

# Named attributes used internally (removed at end of each iteration)
A_EDGE_V1 = "ls_ev_v1"
A_EDGE_V2 = "ls_ev_v2"
A_EDGE_BOUND = "ls_edge_is_boundary"

A_P_OWNER = "ls_owner"
A_P_NEIGHBOR_POS = "ls_neighbor_pos"
A_P_BFLAG = "ls_bflag"      # float 0/1

A_P_SUM_ALL = "ls_sum_all"
A_P_SUM_BND = "ls_sum_bnd"
A_P_N_ALL = "ls_n_all"
A_P_N_BND = "ls_n_bnd"
A_P_TRAIL = "ls_trail"

A_EVEN = "ls_even_pos"
A_ODD = "ls_odd_pos"

A_F_V0 = "ls_f_v0"
A_F_V1 = "ls_f_v1"
A_F_V2 = "ls_f_v2"
A_F_E01 = "ls_f_e01"
A_F_E12 = "ls_f_e12"
A_F_E20 = "ls_f_e20"


# -----------------------------
# Version guard (Blender 5.0+)
# -----------------------------
if bpy.app.version < (5, 0, 0):
    raise RuntimeError(f"Requires Blender 5.0+. Current: {bpy.app.version_string}")


# -----------------------------
# Helpers
# -----------------------------
def ensure_object_mode():
    if bpy.context.mode != "OBJECT":
        bpy.ops.object.mode_set(mode="OBJECT")


def remove_node_group_if_exists(name: str):
    ng = bpy.data.node_groups.get(name)
    if ng:
        bpy.data.node_groups.remove(ng)


def add_group_socket(ng, name: str, in_out: str, socket_type: str, default=None, min_value=None):
    s = ng.interface.new_socket(name=name, in_out=in_out, socket_type=socket_type)
    if default is not None and hasattr(s, "default_value"):
        try:
            s.default_value = default
        except Exception:
            pass
    if min_value is not None and hasattr(s, "min_value"):
        try:
            s.min_value = min_value
        except Exception:
            pass
    return s


def n(tree, idname: str):
    return tree.nodes.new(idname)


def sock_in(node, *cands):
    # Exact match first
    for c in cands:
        if c in node.inputs:
            return node.inputs[c]
    # Partial match fallback
    cl = [c.lower() for c in cands]
    for s in node.inputs:
        sn = s.name.lower()
        if any(c in sn for c in cl):
            return s
    raise KeyError(f"Input socket not found on {node.bl_idname}: {cands}")


def sock_out(node, *cands):
    for c in cands:
        if c in node.outputs:
            return node.outputs[c]
    cl = [c.lower() for c in cands]
    for s in node.outputs:
        sn = s.name.lower()
        if any(c in sn for c in cl):
            return s
    raise KeyError(f"Output socket not found on {node.bl_idname}: {cands}")


def set_enum(node, prop: str, value: str):
    if hasattr(node, prop):
        try:
            setattr(node, prop, value)
            return True
        except Exception:
            return False
    return False


def config_store_named_attr(node, domain, data_type, name: str):
    set_enum(node, "domain", domain)
    set_enum(node, "data_type", data_type)
    sock_in(node, "Name").default_value = name


def config_mesh_to_points(node, mode):
    set_enum(node, "mode", mode)


def config_delete_geometry(node, domain):
    set_enum(node, "domain", domain)


def config_sort_elements(node, domain):
    set_enum(node, "domain", domain)


def config_sample_index(node, domain, data_type):
    set_enum(node, "domain", domain)
    set_enum(node, "data_type", data_type)


def config_switch(node, input_type):
    set_enum(node, "input_type", input_type)


# -----------------------------
# Template object: 1 triangle split into 4 (6 verts)
# Per-vertex int attribute TEMPLATE_SLOT_ATTR in [0..5]
# -----------------------------
def ensure_template_object():
    obj = bpy.data.objects.get(TEMPLATE_OBJ_NAME)
    if obj and obj.type == "MESH":
        return obj

    me = bpy.data.meshes.new(TEMPLATE_OBJ_NAME + "_Mesh")
    obj = bpy.data.objects.new(TEMPLATE_OBJ_NAME, me)
    bpy.context.collection.objects.link(obj)

    # Hide helper
    obj.hide_set(True)
    obj.hide_render = True
    obj.hide_select = True

    bm = bmesh.new()

    sqrt3 = math.sqrt(3.0)
    v0 = bm.verts.new((0.0, 0.0, 0.0))                # slot 0
    v1 = bm.verts.new((1.0, 0.0, 0.0))                # slot 1
    v2 = bm.verts.new((0.5, sqrt3 * 0.5, 0.0))        # slot 2
    m01 = bm.verts.new((0.5, 0.0, 0.0))               # slot 3
    m12 = bm.verts.new((0.75, sqrt3 * 0.25, 0.0))     # slot 4
    m20 = bm.verts.new((0.25, sqrt3 * 0.25, 0.0))     # slot 5

    bm.faces.new((v0, m01, m20))
    bm.faces.new((m01, v1, m12))
    bm.faces.new((m12, v2, m20))
    bm.faces.new((m01, m12, m20))

    bm.to_mesh(me)
    bm.free()
    me.update()

    # Slot attribute
    if TEMPLATE_SLOT_ATTR in me.attributes:
        me.attributes.remove(me.attributes[TEMPLATE_SLOT_ATTR])
    attr = me.attributes.new(TEMPLATE_SLOT_ATTR, "INT", "POINT")
    slot_vals = [0, 1, 2, 3, 4, 5]
    for i in range(len(attr.data)):
        attr.data[i].value = slot_vals[i] if i < len(slot_vals) else 0

    return obj


# -----------------------------
# Opposite vertex group:
# (Face index, edge endpoints) -> third vertex index in that face
# -----------------------------
def make_opp_vertex_group():
    name = "LS_OppVertex_5x"
    remove_node_group_if_exists(name)

    ng = bpy.data.node_groups.new(name, "GeometryNodeTree")
    add_group_socket(ng, "Face", "INPUT", "NodeSocketInt", default=0, min_value=0)
    add_group_socket(ng, "Edge V1", "INPUT", "NodeSocketInt", default=0, min_value=0)
    add_group_socket(ng, "Edge V2", "INPUT", "NodeSocketInt", default=0, min_value=0)
    add_group_socket(ng, "Opp Vertex", "OUTPUT", "NodeSocketInt")

    nodes = ng.nodes
    links = ng.links
    nodes.clear()

    gin = n(ng, "NodeGroupInput")
    gout = n(ng, "NodeGroupOutput")

    cof0 = n(ng, "GeometryNodeCornersOfFace")
    cof1 = n(ng, "GeometryNodeCornersOfFace")
    cof2 = n(ng, "GeometryNodeCornersOfFace")
    sock_in(cof0, "Sort Index").default_value = 0
    sock_in(cof1, "Sort Index").default_value = 1
    sock_in(cof2, "Sort Index").default_value = 2

    voc0 = n(ng, "GeometryNodeVertexOfCorner")
    voc1 = n(ng, "GeometryNodeVertexOfCorner")
    voc2 = n(ng, "GeometryNodeVertexOfCorner")

    links.new(sock_out(gin, "Face"), sock_in(cof0, "Face Index", "Face"))
    links.new(sock_out(gin, "Face"), sock_in(cof1, "Face Index", "Face"))
    links.new(sock_out(gin, "Face"), sock_in(cof2, "Face Index", "Face"))

    links.new(sock_out(cof0, "Corner Index", "Corner"), sock_in(voc0, "Corner Index", "Corner"))
    links.new(sock_out(cof1, "Corner Index", "Corner"), sock_in(voc1, "Corner Index", "Corner"))
    links.new(sock_out(cof2, "Corner Index", "Corner"), sock_in(voc2, "Corner Index", "Corner"))

    # cond0 = (v0 != e1) AND (v0 != e2)
    c0a = n(ng, "FunctionNodeCompare")
    c0b = n(ng, "FunctionNodeCompare")
    c0a.data_type = "INT"
    c0b.data_type = "INT"
    c0a.operation = "NOT_EQUAL"
    c0b.operation = "NOT_EQUAL"
    and0 = n(ng, "FunctionNodeBooleanMath")
    and0.operation = "AND"

    links.new(sock_out(voc0, "Vertex Index", "Vertex"), sock_in(c0a, "A"))
    links.new(sock_out(gin, "Edge V1"), sock_in(c0a, "B"))
    links.new(sock_out(voc0, "Vertex Index", "Vertex"), sock_in(c0b, "A"))
    links.new(sock_out(gin, "Edge V2"), sock_in(c0b, "B"))
    links.new(sock_out(c0a, "Result"), sock_in(and0, "Boolean"))
    links.new(sock_out(c0b, "Result"), sock_in(and0, "Boolean_001", "Boolean"))

    # cond1 = (v1 != e1) AND (v1 != e2)
    c1a = n(ng, "FunctionNodeCompare")
    c1b = n(ng, "FunctionNodeCompare")
    c1a.data_type = "INT"
    c1b.data_type = "INT"
    c1a.operation = "NOT_EQUAL"
    c1b.operation = "NOT_EQUAL"
    and1 = n(ng, "FunctionNodeBooleanMath")
    and1.operation = "AND"

    links.new(sock_out(voc1, "Vertex Index", "Vertex"), sock_in(c1a, "A"))
    links.new(sock_out(gin, "Edge V1"), sock_in(c1a, "B"))
    links.new(sock_out(voc1, "Vertex Index", "Vertex"), sock_in(c1b, "A"))
    links.new(sock_out(gin, "Edge V2"), sock_in(c1b, "B"))
    links.new(sock_out(c1a, "Result"), sock_in(and1, "Boolean"))
    links.new(sock_out(c1b, "Result"), sock_in(and1, "Boolean_001", "Boolean"))

    sw_tmp = n(ng, "GeometryNodeSwitch")
    config_switch(sw_tmp, "INT")
    links.new(sock_out(and1, "Boolean"), sock_in(sw_tmp, "Switch"))
    links.new(sock_out(voc2, "Vertex Index", "Vertex"), sock_in(sw_tmp, "False"))
    links.new(sock_out(voc1, "Vertex Index", "Vertex"), sock_in(sw_tmp, "True"))

    sw_out = n(ng, "GeometryNodeSwitch")
    config_switch(sw_out, "INT")
    links.new(sock_out(and0, "Boolean"), sock_in(sw_out, "Switch"))
    links.new(sock_out(sw_tmp, "Output"), sock_in(sw_out, "False"))
    links.new(sock_out(voc0, "Vertex Index", "Vertex"), sock_in(sw_out, "True"))

    links.new(sock_out(sw_out, "Output"), sock_in(gout, "Opp Vertex"))
    return ng


# -----------------------------
# One Loop subdivision iteration (GN)
# -----------------------------
def make_loop_iter_group(template_obj, opp_group):
    name = "LS_LoopIter_NoSubdivide_5x"
    remove_node_group_if_exists(name)

    ng = bpy.data.node_groups.new(name, "GeometryNodeTree")
    add_group_socket(ng, "Geometry", "INPUT", "NodeSocketGeometry")
    add_group_socket(ng, "Geometry", "OUTPUT", "NodeSocketGeometry")

    nodes = ng.nodes
    links = ng.links
    nodes.clear()

    gin = n(ng, "NodeGroupInput")
    gout = n(ng, "NodeGroupOutput")

    # Triangulate
    tri = n(ng, "GeometryNodeTriangulate")
    links.new(sock_out(gin, "Geometry"), sock_in(tri, "Mesh", "Geometry"))

    # Edge endpoints + boundary flag (Face Count == 1)
    edge_verts = n(ng, "GeometryNodeInputMeshEdgeVertices")
    edge_nei = n(ng, "GeometryNodeInputMeshEdgeNeighbors")

    cmp_edge_bnd = n(ng, "FunctionNodeCompare")
    cmp_edge_bnd.data_type = "INT"
    cmp_edge_bnd.operation = "EQUAL"
    sock_in(cmp_edge_bnd, "B").default_value = 1
    links.new(sock_out(edge_nei, "Face Count"), sock_in(cmp_edge_bnd, "A"))

    st_v1 = n(ng, "GeometryNodeStoreNamedAttribute")
    config_store_named_attr(st_v1, "EDGE", "INT", A_EDGE_V1)
    links.new(sock_out(tri, "Mesh", "Geometry"), sock_in(st_v1, "Geometry"))
    links.new(sock_out(edge_verts, "Vertex Index 1", "Vertex Index", "Vertex"), sock_in(st_v1, "Value"))

    st_v2 = n(ng, "GeometryNodeStoreNamedAttribute")
    config_store_named_attr(st_v2, "EDGE", "INT", A_EDGE_V2)
    links.new(sock_out(st_v1, "Geometry"), sock_in(st_v2, "Geometry"))
    links.new(sock_out(edge_verts, "Vertex Index 2", "Vertex Index", "Vertex"), sock_in(st_v2, "Value"))

    st_bnd = n(ng, "GeometryNodeStoreNamedAttribute")
    config_store_named_attr(st_bnd, "EDGE", "BOOLEAN", A_EDGE_BOUND)
    links.new(sock_out(st_v2, "Geometry"), sock_in(st_bnd, "Geometry"))
    links.new(sock_out(cmp_edge_bnd, "Result"), sock_in(st_bnd, "Value"))

    mesh_with_edge_attrs = st_bnd

    # Build contributions: edges -> points, duplicated twice (owner=v1 and owner=v2)
    m2p_edges = n(ng, "GeometryNodeMeshToPoints")
    config_mesh_to_points(m2p_edges, "EDGES")
    links.new(sock_out(mesh_with_edge_attrs, "Geometry"), sock_in(m2p_edges, "Mesh", "Geometry"))

    na_v1 = n(ng, "GeometryNodeInputNamedAttribute")
    sock_in(na_v1, "Name").default_value = A_EDGE_V1
    na_v2 = n(ng, "GeometryNodeInputNamedAttribute")
    sock_in(na_v2, "Name").default_value = A_EDGE_V2
    na_bedge = n(ng, "GeometryNodeInputNamedAttribute")
    sock_in(na_bedge, "Name").default_value = A_EDGE_BOUND

    pos = n(ng, "GeometryNodeInputPosition")

    # Sample Index (we need geometry socket for cross-geometry sampling later)
    def sample_index(domain, data_type):
        s = n(ng, "GeometryNodeSampleIndex")
        config_sample_index(s, domain, data_type)
        return s

    # A: owner=v1, neighbor=v2
    s_owner_pos_a = sample_index("POINT", "FLOAT_VECTOR")
    s_nei_pos_a = sample_index("POINT", "FLOAT_VECTOR")
    links.new(sock_out(mesh_with_edge_attrs, "Geometry"), sock_in(s_owner_pos_a, "Geometry"))
    links.new(sock_out(pos, "Position"), sock_in(s_owner_pos_a, "Value"))
    links.new(sock_out(na_v1, "Attribute"), sock_in(s_owner_pos_a, "Index"))

    links.new(sock_out(mesh_with_edge_attrs, "Geometry"), sock_in(s_nei_pos_a, "Geometry"))
    links.new(sock_out(pos, "Position"), sock_in(s_nei_pos_a, "Value"))
    links.new(sock_out(na_v2, "Attribute"), sock_in(s_nei_pos_a, "Index"))

    sp_a = n(ng, "GeometryNodeSetPosition")
    links.new(sock_out(m2p_edges, "Points", "Geometry"), sock_in(sp_a, "Geometry"))
    links.new(sock_out(s_owner_pos_a, "Value"), sock_in(sp_a, "Position"))

    sw_bflag_a = n(ng, "GeometryNodeSwitch")
    config_switch(sw_bflag_a, "FLOAT")
    sock_in(sw_bflag_a, "True").default_value = 1.0
    sock_in(sw_bflag_a, "False").default_value = 0.0
    links.new(sock_out(na_bedge, "Attribute"), sock_in(sw_bflag_a, "Switch"))

    st_owner_a = n(ng, "GeometryNodeStoreNamedAttribute")
    config_store_named_attr(st_owner_a, "POINT", "INT", A_P_OWNER)
    links.new(sock_out(sp_a, "Geometry"), sock_in(st_owner_a, "Geometry"))
    links.new(sock_out(na_v1, "Attribute"), sock_in(st_owner_a, "Value"))

    st_nei_a = n(ng, "GeometryNodeStoreNamedAttribute")
    config_store_named_attr(st_nei_a, "POINT", "FLOAT_VECTOR", A_P_NEIGHBOR_POS)
    links.new(sock_out(st_owner_a, "Geometry"), sock_in(st_nei_a, "Geometry"))
    links.new(sock_out(s_nei_pos_a, "Value"), sock_in(st_nei_a, "Value"))

    st_bflag_a = n(ng, "GeometryNodeStoreNamedAttribute")
    config_store_named_attr(st_bflag_a, "POINT", "FLOAT", A_P_BFLAG)
    links.new(sock_out(st_nei_a, "Geometry"), sock_in(st_bflag_a, "Geometry"))
    links.new(sock_out(sw_bflag_a, "Output"), sock_in(st_bflag_a, "Value"))

    # B: owner=v2, neighbor=v1
    s_owner_pos_b = sample_index("POINT", "FLOAT_VECTOR")
    s_nei_pos_b = sample_index("POINT", "FLOAT_VECTOR")
    links.new(sock_out(mesh_with_edge_attrs, "Geometry"), sock_in(s_owner_pos_b, "Geometry"))
    links.new(sock_out(pos, "Position"), sock_in(s_owner_pos_b, "Value"))
    links.new(sock_out(na_v2, "Attribute"), sock_in(s_owner_pos_b, "Index"))

    links.new(sock_out(mesh_with_edge_attrs, "Geometry"), sock_in(s_nei_pos_b, "Geometry"))
    links.new(sock_out(pos, "Position"), sock_in(s_nei_pos_b, "Value"))
    links.new(sock_out(na_v1, "Attribute"), sock_in(s_nei_pos_b, "Index"))

    sp_b = n(ng, "GeometryNodeSetPosition")
    links.new(sock_out(m2p_edges, "Points", "Geometry"), sock_in(sp_b, "Geometry"))
    links.new(sock_out(s_owner_pos_b, "Value"), sock_in(sp_b, "Position"))

    sw_bflag_b = n(ng, "GeometryNodeSwitch")
    config_switch(sw_bflag_b, "FLOAT")
    sock_in(sw_bflag_b, "True").default_value = 1.0
    sock_in(sw_bflag_b, "False").default_value = 0.0
    links.new(sock_out(na_bedge, "Attribute"), sock_in(sw_bflag_b, "Switch"))

    st_owner_b = n(ng, "GeometryNodeStoreNamedAttribute")
    config_store_named_attr(st_owner_b, "POINT", "INT", A_P_OWNER)
    links.new(sock_out(sp_b, "Geometry"), sock_in(st_owner_b, "Geometry"))
    links.new(sock_out(na_v2, "Attribute"), sock_in(st_owner_b, "Value"))

    st_nei_b = n(ng, "GeometryNodeStoreNamedAttribute")
    config_store_named_attr(st_nei_b, "POINT", "FLOAT_VECTOR", A_P_NEIGHBOR_POS)
    links.new(sock_out(st_owner_b, "Geometry"), sock_in(st_nei_b, "Geometry"))
    links.new(sock_out(s_nei_pos_b, "Value"), sock_in(st_nei_b, "Value"))

    st_bflag_b = n(ng, "GeometryNodeStoreNamedAttribute")
    config_store_named_attr(st_bflag_b, "POINT", "FLOAT", A_P_BFLAG)
    links.new(sock_out(st_nei_b, "Geometry"), sock_in(st_bflag_b, "Geometry"))
    links.new(sock_out(sw_bflag_b, "Output"), sock_in(st_bflag_b, "Value"))

    join = n(ng, "GeometryNodeJoinGeometry")
    links.new(sock_out(st_bflag_a, "Geometry"), sock_in(join, "Geometry"))
    links.new(sock_out(st_bflag_b, "Geometry"), sock_in(join, "Geometry"))
    contributions = join

    # Accumulate per owner
    na_owner = n(ng, "GeometryNodeInputNamedAttribute")
    sock_in(na_owner, "Name").default_value = A_P_OWNER
    na_nei_pos = n(ng, "GeometryNodeInputNamedAttribute")
    sock_in(na_nei_pos, "Name").default_value = A_P_NEIGHBOR_POS
    na_bflag = n(ng, "GeometryNodeInputNamedAttribute")
    sock_in(na_bflag, "Name").default_value = A_P_BFLAG

    scale_bnd = n(ng, "ShaderNodeVectorMath")
    scale_bnd.operation = "SCALE"
    links.new(sock_out(na_nei_pos, "Attribute"), sock_in(scale_bnd, "Vector"))
    links.new(sock_out(na_bflag, "Attribute"), sock_in(scale_bnd, "Scale"))

    acc_sum_all = n(ng, "GeometryNodeAccumulateField")
    acc_sum_bnd = n(ng, "GeometryNodeAccumulateField")
    acc_n_all = n(ng, "GeometryNodeAccumulateField")
    acc_n_bnd = n(ng, "GeometryNodeAccumulateField")

    # group socket name differs; try both
    def link_group(acc, group_out):
        try:
            links.new(group_out, sock_in(acc, "Group Index"))
        except KeyError:
            links.new(group_out, sock_in(acc, "Group ID"))

    links.new(sock_out(na_nei_pos, "Attribute"), sock_in(acc_sum_all, "Value"))
    link_group(acc_sum_all, sock_out(na_owner, "Attribute"))

    links.new(sock_out(scale_bnd, "Vector"), sock_in(acc_sum_bnd, "Value"))
    link_group(acc_sum_bnd, sock_out(na_owner, "Attribute"))

    one = n(ng, "ShaderNodeMath")
    one.operation = "ADD"
    one.inputs[0].default_value = 1.0
    one.inputs[1].default_value = 0.0

    links.new(sock_out(one, "Value"), sock_in(acc_n_all, "Value"))
    link_group(acc_n_all, sock_out(na_owner, "Attribute"))

    links.new(sock_out(na_bflag, "Attribute"), sock_in(acc_n_bnd, "Value"))
    link_group(acc_n_bnd, sock_out(na_owner, "Attribute"))

    # Store totals + trailing on contributions
    st_sum_all = n(ng, "GeometryNodeStoreNamedAttribute")
    config_store_named_attr(st_sum_all, "POINT", "FLOAT_VECTOR", A_P_SUM_ALL)
    links.new(sock_out(contributions, "Geometry"), sock_in(st_sum_all, "Geometry"))
    links.new(sock_out(acc_sum_all, "Total"), sock_in(st_sum_all, "Value"))

    st_sum_bnd = n(ng, "GeometryNodeStoreNamedAttribute")
    config_store_named_attr(st_sum_bnd, "POINT", "FLOAT_VECTOR", A_P_SUM_BND)
    links.new(sock_out(st_sum_all, "Geometry"), sock_in(st_sum_bnd, "Geometry"))
    links.new(sock_out(acc_sum_bnd, "Total"), sock_in(st_sum_bnd, "Value"))

    st_n_all = n(ng, "GeometryNodeStoreNamedAttribute")
    config_store_named_attr(st_n_all, "POINT", "FLOAT", A_P_N_ALL)
    links.new(sock_out(st_sum_bnd, "Geometry"), sock_in(st_n_all, "Geometry"))
    links.new(sock_out(acc_n_all, "Total"), sock_in(st_n_all, "Value"))

    st_n_bnd = n(ng, "GeometryNodeStoreNamedAttribute")
    config_store_named_attr(st_n_bnd, "POINT", "FLOAT", A_P_N_BND)
    links.new(sock_out(st_n_all, "Geometry"), sock_in(st_n_bnd, "Geometry"))
    links.new(sock_out(acc_n_bnd, "Total"), sock_in(st_n_bnd, "Value"))

    st_trail = n(ng, "GeometryNodeStoreNamedAttribute")
    config_store_named_attr(st_trail, "POINT", "FLOAT", A_P_TRAIL)
    links.new(sock_out(st_n_bnd, "Geometry"), sock_in(st_trail, "Geometry"))
    links.new(sock_out(acc_n_all, "Trailing"), sock_in(st_trail, "Value"))

    # Keep one point per owner: delete where trail > 0
    na_trail = n(ng, "GeometryNodeInputNamedAttribute")
    sock_in(na_trail, "Name").default_value = A_P_TRAIL
    cmp_trail = n(ng, "FunctionNodeCompare")
    cmp_trail.data_type = "FLOAT"
    cmp_trail.operation = "GREATER_THAN"
    sock_in(cmp_trail, "B").default_value = 0.0
    links.new(sock_out(na_trail, "Attribute"), sock_in(cmp_trail, "A"))

    delete = n(ng, "GeometryNodeDeleteGeometry")
    config_delete_geometry(delete, "POINT")
    links.new(sock_out(st_trail, "Geometry"), sock_in(delete, "Geometry"))
    links.new(sock_out(cmp_trail, "Result"), sock_in(delete, "Selection"))

    # Sort by owner so point index == vertex index
    sort = n(ng, "GeometryNodeSortElements")
    config_sort_elements(sort, "POINT")
    links.new(sock_out(delete, "Geometry"), sock_in(sort, "Geometry"))
    links.new(sock_out(na_owner, "Attribute"), sock_in(sort, "Sort Weight", "Sort"))

    vertex_info = sort

    # Sample stats by vertex index
    idx = n(ng, "GeometryNodeInputIndex")

    def sample_from_vertex_info(attr_name, data_type, domain="POINT"):
        na = n(ng, "GeometryNodeInputNamedAttribute")
        sock_in(na, "Name").default_value = attr_name
        s = n(ng, "GeometryNodeSampleIndex")
        config_sample_index(s, domain, data_type)
        links.new(sock_out(vertex_info, "Geometry"), sock_in(s, "Geometry"))
        links.new(sock_out(na, "Attribute"), sock_in(s, "Value"))
        links.new(sock_out(idx, "Index"), sock_in(s, "Index"))
        return s

    s_sum_all_v = sample_from_vertex_info(A_P_SUM_ALL, "FLOAT_VECTOR")
    s_sum_bnd_v = sample_from_vertex_info(A_P_SUM_BND, "FLOAT_VECTOR")
    s_n_all_v = sample_from_vertex_info(A_P_N_ALL, "FLOAT")
    s_n_bnd_v = sample_from_vertex_info(A_P_N_BND, "FLOAT")

    # Beta computation
    n_clamp = n(ng, "ShaderNodeMath")
    n_clamp.operation = "MAXIMUM"
    sock_in(n_clamp, "Value_001").default_value = 1.0
    links.new(sock_out(s_n_all_v, "Value"), sock_in(n_clamp, "Value"))

    tau_over_n = n(ng, "ShaderNodeMath")
    tau_over_n.operation = "DIVIDE"
    tau_over_n.inputs[0].default_value = math.tau
    links.new(sock_out(n_clamp, "Value"), sock_in(tau_over_n, "Value_001"))

    cosn = n(ng, "ShaderNodeMath")
    cosn.operation = "COSINE"
    links.new(sock_out(tau_over_n, "Value"), sock_in(cosn, "Value"))

    qcos = n(ng, "ShaderNodeMath")
    qcos.operation = "MULTIPLY"
    qcos.inputs[1].default_value = 0.25
    links.new(sock_out(cosn, "Value"), sock_in(qcos, "Value"))

    val = n(ng, "ShaderNodeMath")
    val.operation = "ADD"
    val.inputs[1].default_value = 3.0 / 8.0
    links.new(sock_out(qcos, "Value"), sock_in(val, "Value"))

    val_sq = n(ng, "ShaderNodeMath")
    val_sq.operation = "MULTIPLY"
    links.new(sock_out(val, "Value"), sock_in(val_sq, "Value"))
    links.new(sock_out(val, "Value"), sock_in(val_sq, "Value_001"))

    term = n(ng, "ShaderNodeMath")
    term.operation = "SUBTRACT"
    term.inputs[0].default_value = 5.0 / 8.0
    links.new(sock_out(val_sq, "Value"), sock_in(term, "Value_001"))

    beta = n(ng, "ShaderNodeMath")
    beta.operation = "DIVIDE"
    links.new(sock_out(term, "Value"), sock_in(beta, "Value"))
    links.new(sock_out(n_clamp, "Value"), sock_in(beta, "Value_001"))

    # interior_even = (1 - n*beta)*P + beta*sum_all
    n_beta = n(ng, "ShaderNodeMath")
    n_beta.operation = "MULTIPLY"
    links.new(sock_out(beta, "Value"), sock_in(n_beta, "Value"))
    links.new(sock_out(s_n_all_v, "Value"), sock_in(n_beta, "Value_001"))

    w_self = n(ng, "ShaderNodeMath")
    w_self.operation = "SUBTRACT"
    w_self.inputs[0].default_value = 1.0
    links.new(sock_out(n_beta, "Value"), sock_in(w_self, "Value_001"))

    v_self = n(ng, "ShaderNodeVectorMath")
    v_self.operation = "SCALE"
    links.new(sock_out(pos, "Position"), sock_in(v_self, "Vector"))
    links.new(sock_out(w_self, "Value"), sock_in(v_self, "Scale"))

    v_nei = n(ng, "ShaderNodeVectorMath")
    v_nei.operation = "SCALE"
    links.new(sock_out(s_sum_all_v, "Value"), sock_in(v_nei, "Vector"))
    links.new(sock_out(beta, "Value"), sock_in(v_nei, "Scale"))

    interior_even = n(ng, "ShaderNodeVectorMath")
    interior_even.operation = "ADD"
    links.new(sock_out(v_self, "Vector"), sock_in(interior_even, "Vector"))
    links.new(sock_out(v_nei, "Vector"), sock_in(interior_even, "Vector_001"))

    # boundary_even = 0.75*P + 0.125*sum_bnd
    b_self = n(ng, "ShaderNodeVectorMath")
    b_self.operation = "SCALE"
    sock_in(b_self, "Scale").default_value = 0.75
    links.new(sock_out(pos, "Position"), sock_in(b_self, "Vector"))

    b_nei = n(ng, "ShaderNodeVectorMath")
    b_nei.operation = "SCALE"
    sock_in(b_nei, "Scale").default_value = 0.125
    links.new(sock_out(s_sum_bnd_v, "Value"), sock_in(b_nei, "Vector"))

    boundary_even = n(ng, "ShaderNodeVectorMath")
    boundary_even.operation = "ADD"
    links.new(sock_out(b_self, "Vector"), sock_in(boundary_even, "Vector"))
    links.new(sock_out(b_nei, "Vector"), sock_in(boundary_even, "Vector_001"))

    is_valid_bnd = n(ng, "FunctionNodeCompare")
    is_valid_bnd.data_type = "FLOAT"
    is_valid_bnd.operation = "EQUAL"
    sock_in(is_valid_bnd, "B").default_value = 2.0
    links.new(sock_out(s_n_bnd_v, "Value"), sock_in(is_valid_bnd, "A"))

    has_bnd = n(ng, "FunctionNodeCompare")
    has_bnd.data_type = "FLOAT"
    has_bnd.operation = "GREATER_THAN"
    sock_in(has_bnd, "B").default_value = 0.0
    links.new(sock_out(s_n_bnd_v, "Value"), sock_in(has_bnd, "A"))

    is_isolated = n(ng, "FunctionNodeCompare")
    is_isolated.data_type = "FLOAT"
    is_isolated.operation = "EQUAL"
    sock_in(is_isolated, "B").default_value = 0.0
    links.new(sock_out(s_n_all_v, "Value"), sock_in(is_isolated, "A"))

    sw_iso = n(ng, "GeometryNodeSwitch")
    config_switch(sw_iso, "VECTOR")
    links.new(sock_out(is_isolated, "Result"), sock_in(sw_iso, "Switch"))
    links.new(sock_out(interior_even, "Vector"), sock_in(sw_iso, "False"))
    links.new(sock_out(pos, "Position"), sock_in(sw_iso, "True"))

    # boundary corner fallback: if has boundary but not valid -> keep P
    sw_bnd_keep = n(ng, "GeometryNodeSwitch")
    config_switch(sw_bnd_keep, "VECTOR")
    links.new(sock_out(has_bnd, "Result"), sock_in(sw_bnd_keep, "Switch"))
    links.new(sock_out(sw_iso, "Output"), sock_in(sw_bnd_keep, "False"))
    links.new(sock_out(pos, "Position"), sock_in(sw_bnd_keep, "True"))

    sw_valid = n(ng, "GeometryNodeSwitch")
    config_switch(sw_valid, "VECTOR")
    links.new(sock_out(is_valid_bnd, "Result"), sock_in(sw_valid, "Switch"))
    links.new(sock_out(sw_bnd_keep, "Output"), sock_in(sw_valid, "False"))
    links.new(sock_out(boundary_even, "Vector"), sock_in(sw_valid, "True"))

    st_even = n(ng, "GeometryNodeStoreNamedAttribute")
    config_store_named_attr(st_even, "POINT", "FLOAT_VECTOR", A_EVEN)
    links.new(sock_out(mesh_with_edge_attrs, "Geometry"), sock_in(st_even, "Geometry"))
    links.new(sock_out(sw_valid, "Output"), sock_in(st_even, "Value"))

    # Odd positions on edges
    edge_verts2 = n(ng, "GeometryNodeInputMeshEdgeVertices")
    edge_nei2 = n(ng, "GeometryNodeInputMeshEdgeNeighbors")
    cmp_edge_bnd2 = n(ng, "FunctionNodeCompare")
    cmp_edge_bnd2.data_type = "INT"
    cmp_edge_bnd2.operation = "EQUAL"
    sock_in(cmp_edge_bnd2, "B").default_value = 1
    links.new(sock_out(edge_nei2, "Face Count"), sock_in(cmp_edge_bnd2, "A"))

    # endpoint positions
    s_p1 = sample_index("POINT", "FLOAT_VECTOR")
    s_p2 = sample_index("POINT", "FLOAT_VECTOR")
    links.new(sock_out(st_even, "Geometry"), sock_in(s_p1, "Geometry"))
    links.new(sock_out(pos, "Position"), sock_in(s_p1, "Value"))
    links.new(sock_out(edge_verts2, "Vertex Index 1", "Vertex Index", "Vertex"), sock_in(s_p1, "Index"))

    links.new(sock_out(st_even, "Geometry"), sock_in(s_p2, "Geometry"))
    links.new(sock_out(pos, "Position"), sock_in(s_p2, "Value"))
    links.new(sock_out(edge_verts2, "Vertex Index 2", "Vertex Index", "Vertex"), sock_in(s_p2, "Index"))

    sum_end = n(ng, "ShaderNodeVectorMath")
    sum_end.operation = "ADD"
    links.new(sock_out(s_p1, "Value"), sock_in(sum_end, "Vector"))
    links.new(sock_out(s_p2, "Value"), sock_in(sum_end, "Vector_001"))

    midpoint = n(ng, "ShaderNodeVectorMath")
    midpoint.operation = "SCALE"
    sock_in(midpoint, "Scale").default_value = 0.5
    links.new(sock_out(sum_end, "Vector"), sock_in(midpoint, "Vector"))

    # Opp vertices via Corners of Edge -> Face of Corner -> OppGroup
    coe0 = n(ng, "GeometryNodeCornersOfEdge")
    coe1 = n(ng, "GeometryNodeCornersOfEdge")
    sock_in(coe0, "Sort Index").default_value = 0
    sock_in(coe1, "Sort Index").default_value = 1

    idx_edge = n(ng, "GeometryNodeInputIndex")
    links.new(sock_out(idx_edge, "Index"), sock_in(coe0, "Edge Index", "Edge"))
    links.new(sock_out(idx_edge, "Index"), sock_in(coe1, "Edge Index", "Edge"))

    foc0 = n(ng, "GeometryNodeFaceOfCorner")
    foc1 = n(ng, "GeometryNodeFaceOfCorner")
    links.new(sock_out(coe0, "Corner Index", "Corner"), sock_in(foc0, "Corner Index", "Corner"))
    links.new(sock_out(coe1, "Corner Index", "Corner"), sock_in(foc1, "Corner Index", "Corner"))

    gopp0 = n(ng, "GeometryNodeGroup")
    gopp0.node_tree = opp_group
    gopp1 = n(ng, "GeometryNodeGroup")
    gopp1.node_tree = opp_group

    links.new(sock_out(foc0, "Face Index", "Face"), sock_in(gopp0, "Face"))
    links.new(sock_out(edge_verts2, "Vertex Index 1", "Vertex"), sock_in(gopp0, "Edge V1"))
    links.new(sock_out(edge_verts2, "Vertex Index 2", "Vertex"), sock_in(gopp0, "Edge V2"))

    links.new(sock_out(foc1, "Face Index", "Face"), sock_in(gopp1, "Face"))
    links.new(sock_out(edge_verts2, "Vertex Index 1", "Vertex"), sock_in(gopp1, "Edge V1"))
    links.new(sock_out(edge_verts2, "Vertex Index 2", "Vertex"), sock_in(gopp1, "Edge V2"))

    s_opp0 = sample_index("POINT", "FLOAT_VECTOR")
    s_opp1 = sample_index("POINT", "FLOAT_VECTOR")
    links.new(sock_out(st_even, "Geometry"), sock_in(s_opp0, "Geometry"))
    links.new(sock_out(pos, "Position"), sock_in(s_opp0, "Value"))
    links.new(sock_out(gopp0, "Opp Vertex"), sock_in(s_opp0, "Index"))

    links.new(sock_out(st_even, "Geometry"), sock_in(s_opp1, "Geometry"))
    links.new(sock_out(pos, "Position"), sock_in(s_opp1, "Value"))
    links.new(sock_out(gopp1, "Opp Vertex"), sock_in(s_opp1, "Index"))

    sum_opp = n(ng, "ShaderNodeVectorMath")
    sum_opp.operation = "ADD"
    links.new(sock_out(s_opp0, "Value"), sock_in(sum_opp, "Vector"))
    links.new(sock_out(s_opp1, "Value"), sock_in(sum_opp, "Vector_001"))

    part1 = n(ng, "ShaderNodeVectorMath")
    part1.operation = "SCALE"
    sock_in(part1, "Scale").default_value = 3.0 / 8.0
    links.new(sock_out(sum_end, "Vector"), sock_in(part1, "Vector"))

    part2 = n(ng, "ShaderNodeVectorMath")
    part2.operation = "SCALE"
    sock_in(part2, "Scale").default_value = 1.0 / 8.0
    links.new(sock_out(sum_opp, "Vector"), sock_in(part2, "Vector"))

    interior_odd = n(ng, "ShaderNodeVectorMath")
    interior_odd.operation = "ADD"
    links.new(sock_out(part1, "Vector"), sock_in(interior_odd, "Vector"))
    links.new(sock_out(part2, "Vector"), sock_in(interior_odd, "Vector_001"))

    sw_edge = n(ng, "GeometryNodeSwitch")
    config_switch(sw_edge, "VECTOR")
    links.new(sock_out(cmp_edge_bnd2, "Result"), sock_in(sw_edge, "Switch"))
    links.new(sock_out(interior_odd, "Vector"), sock_in(sw_edge, "False"))
    links.new(sock_out(midpoint, "Vector"), sock_in(sw_edge, "True"))

    st_odd = n(ng, "GeometryNodeStoreNamedAttribute")
    config_store_named_attr(st_odd, "EDGE", "FLOAT_VECTOR", A_ODD)
    links.new(sock_out(st_even, "Geometry"), sock_in(st_odd, "Geometry"))
    links.new(sock_out(sw_edge, "Output"), sock_in(st_odd, "Value"))

    mesh_attrs = st_odd

    # Per-face attributes for instancing template
    cof_f0 = n(ng, "GeometryNodeCornersOfFace")
    cof_f1 = n(ng, "GeometryNodeCornersOfFace")
    cof_f2 = n(ng, "GeometryNodeCornersOfFace")
    sock_in(cof_f0, "Sort Index").default_value = 0
    sock_in(cof_f1, "Sort Index").default_value = 1
    sock_in(cof_f2, "Sort Index").default_value = 2

    voc_f0 = n(ng, "GeometryNodeVertexOfCorner")
    voc_f1 = n(ng, "GeometryNodeVertexOfCorner")
    voc_f2 = n(ng, "GeometryNodeVertexOfCorner")

    links.new(sock_out(cof_f0, "Corner Index"), sock_in(voc_f0, "Corner Index"))
    links.new(sock_out(cof_f1, "Corner Index"), sock_in(voc_f1, "Corner Index"))
    links.new(sock_out(cof_f2, "Corner Index"), sock_in(voc_f2, "Corner Index"))

    na_even = n(ng, "GeometryNodeInputNamedAttribute")
    sock_in(na_even, "Name").default_value = A_EVEN
    na_odd = n(ng, "GeometryNodeInputNamedAttribute")
    sock_in(na_odd, "Name").default_value = A_ODD

    def sample_even_from_vertex(voc):
        s = n(ng, "GeometryNodeSampleIndex")
        config_sample_index(s, "POINT", "FLOAT_VECTOR")
        links.new(sock_out(mesh_attrs, "Geometry"), sock_in(s, "Geometry"))
        links.new(sock_out(na_even, "Attribute"), sock_in(s, "Value"))
        links.new(sock_out(voc, "Vertex Index", "Vertex"), sock_in(s, "Index"))
        return s

    s_v0 = sample_even_from_vertex(voc_f0)
    s_v1 = sample_even_from_vertex(voc_f1)
    s_v2 = sample_even_from_vertex(voc_f2)

    eoc0 = n(ng, "GeometryNodeEdgesOfCorner")
    eoc1 = n(ng, "GeometryNodeEdgesOfCorner")
    eoc2 = n(ng, "GeometryNodeEdgesOfCorner")
    links.new(sock_out(cof_f0, "Corner Index"), sock_in(eoc0, "Corner Index"))
    links.new(sock_out(cof_f1, "Corner Index"), sock_in(eoc1, "Corner Index"))
    links.new(sock_out(cof_f2, "Corner Index"), sock_in(eoc2, "Corner Index"))

    e01 = sock_out(eoc0, "Next Edge Index", "Next Edge", "Next")
    e12 = sock_out(eoc1, "Next Edge Index", "Next Edge", "Next")
    e20 = sock_out(eoc2, "Next Edge Index", "Next Edge", "Next")

    def sample_odd_from_edge(edge_index_socket):
        s = n(ng, "GeometryNodeSampleIndex")
        config_sample_index(s, "EDGE", "FLOAT_VECTOR")
        links.new(sock_out(mesh_attrs, "Geometry"), sock_in(s, "Geometry"))
        links.new(sock_out(na_odd, "Attribute"), sock_in(s, "Value"))
        links.new(edge_index_socket, sock_in(s, "Index"))
        return s

    s_e01 = sample_odd_from_edge(e01)
    s_e12 = sample_odd_from_edge(e12)
    s_e20 = sample_odd_from_edge(e20)

    # Store face attrs
    st_fv0 = n(ng, "GeometryNodeStoreNamedAttribute")
    config_store_named_attr(st_fv0, "FACE", "FLOAT_VECTOR", A_F_V0)
    links.new(sock_out(mesh_attrs, "Geometry"), sock_in(st_fv0, "Geometry"))
    links.new(sock_out(s_v0, "Value"), sock_in(st_fv0, "Value"))

    st_fv1 = n(ng, "GeometryNodeStoreNamedAttribute")
    config_store_named_attr(st_fv1, "FACE", "FLOAT_VECTOR", A_F_V1)
    links.new(sock_out(st_fv0, "Geometry"), sock_in(st_fv1, "Geometry"))
    links.new(sock_out(s_v1, "Value"), sock_in(st_fv1, "Value"))

    st_fv2 = n(ng, "GeometryNodeStoreNamedAttribute")
    config_store_named_attr(st_fv2, "FACE", "FLOAT_VECTOR", A_F_V2)
    links.new(sock_out(st_fv1, "Geometry"), sock_in(st_fv2, "Geometry"))
    links.new(sock_out(s_v2, "Value"), sock_in(st_fv2, "Value"))

    st_fe01 = n(ng, "GeometryNodeStoreNamedAttribute")
    config_store_named_attr(st_fe01, "FACE", "FLOAT_VECTOR", A_F_E01)
    links.new(sock_out(st_fv2, "Geometry"), sock_in(st_fe01, "Geometry"))
    links.new(sock_out(s_e01, "Value"), sock_in(st_fe01, "Value"))

    st_fe12 = n(ng, "GeometryNodeStoreNamedAttribute")
    config_store_named_attr(st_fe12, "FACE", "FLOAT_VECTOR", A_F_E12)
    links.new(sock_out(st_fe01, "Geometry"), sock_in(st_fe12, "Geometry"))
    links.new(sock_out(s_e12, "Value"), sock_in(st_fe12, "Value"))

    st_fe20 = n(ng, "GeometryNodeStoreNamedAttribute")
    config_store_named_attr(st_fe20, "FACE", "FLOAT_VECTOR", A_F_E20)
    links.new(sock_out(st_fe12, "Geometry"), sock_in(st_fe20, "Geometry"))
    links.new(sock_out(s_e20, "Value"), sock_in(st_fe20, "Value"))

    # Face -> points, instance template, realize
    m2p_faces = n(ng, "GeometryNodeMeshToPoints")
    config_mesh_to_points(m2p_faces, "FACES")
    links.new(sock_out(st_fe20, "Geometry"), sock_in(m2p_faces, "Mesh", "Geometry"))

    obj_info = n(ng, "GeometryNodeObjectInfo")
    sock_in(obj_info, "Object").default_value = template_obj
    try:
        obj_info.as_instance = True
    except Exception:
        pass

    inst = n(ng, "GeometryNodeInstanceOnPoints")
    links.new(sock_out(m2p_faces, "Points", "Geometry"), sock_in(inst, "Points", "Geometry"))
    links.new(sock_out(obj_info, "Geometry"), sock_in(inst, "Instance", "Geometry"))

    realize = n(ng, "GeometryNodeRealizeInstances")
    links.new(sock_out(inst, "Instances", "Geometry"), sock_in(realize, "Geometry"))

    # Set position based on slot [0..5] mapping to {v0,v1,v2,e01,e12,e20}
    na_slot = n(ng, "GeometryNodeInputNamedAttribute")
    sock_in(na_slot, "Name").default_value = TEMPLATE_SLOT_ATTR

    na_fv0 = n(ng, "GeometryNodeInputNamedAttribute"); sock_in(na_fv0, "Name").default_value = A_F_V0
    na_fv1 = n(ng, "GeometryNodeInputNamedAttribute"); sock_in(na_fv1, "Name").default_value = A_F_V1
    na_fv2 = n(ng, "GeometryNodeInputNamedAttribute"); sock_in(na_fv2, "Name").default_value = A_F_V2
    na_fe01 = n(ng, "GeometryNodeInputNamedAttribute"); sock_in(na_fe01, "Name").default_value = A_F_E01
    na_fe12 = n(ng, "GeometryNodeInputNamedAttribute"); sock_in(na_fe12, "Name").default_value = A_F_E12
    na_fe20 = n(ng, "GeometryNodeInputNamedAttribute"); sock_in(na_fe20, "Name").default_value = A_F_E20

    def slot_eq(k):
        c = n(ng, "FunctionNodeCompare")
        c.data_type = "INT"
        c.operation = "EQUAL"
        sock_in(c, "B").default_value = k
        links.new(sock_out(na_slot, "Attribute"), sock_in(c, "A"))
        return c

    cur_vec = na_fe20
    for k, src in [(4, na_fe12), (3, na_fe01), (2, na_fv2), (1, na_fv1), (0, na_fv0)]:
        sw = n(ng, "GeometryNodeSwitch")
        config_switch(sw, "VECTOR")
        links.new(sock_out(slot_eq(k), "Result"), sock_in(sw, "Switch"))
        links.new(sock_out(cur_vec, "Attribute"), sock_in(sw, "False"))
        links.new(sock_out(src, "Attribute"), sock_in(sw, "True"))
        cur_vec = sw

    setp = n(ng, "GeometryNodeSetPosition")
    links.new(sock_out(realize, "Geometry"), sock_in(setp, "Geometry"))
    links.new(sock_out(cur_vec, "Output"), sock_in(setp, "Position"))

    merge = n(ng, "GeometryNodeMergeByDistance")
    sock_in(merge, "Distance").default_value = MERGE_DISTANCE
    links.new(sock_out(setp, "Geometry"), sock_in(merge, "Geometry"))

    # Cleanup: remove all temporary attrs (incl. template slot)
    cleanup_names = [
        TEMPLATE_SLOT_ATTR,
        A_EDGE_V1, A_EDGE_V2, A_EDGE_BOUND,
        A_P_OWNER, A_P_NEIGHBOR_POS, A_P_BFLAG, A_P_SUM_ALL, A_P_SUM_BND, A_P_N_ALL, A_P_N_BND, A_P_TRAIL,
        A_EVEN, A_ODD,
        A_F_V0, A_F_V1, A_F_V2, A_F_E01, A_F_E12, A_F_E20,
    ]
    g = merge
    for nm in cleanup_names:
        rm = n(ng, "GeometryNodeRemoveNamedAttribute")
        links.new(sock_out(g, "Geometry"), sock_in(rm, "Geometry"))
        sock_in(rm, "Name").default_value = nm
        g = rm

    links.new(sock_out(g, "Geometry"), sock_in(gout, "Geometry"))
    return ng


# -----------------------------
# Wrapper group with Repeat Zone (Iterations input)
# -----------------------------
def make_repeat_wrapper(iter_group, default_iterations: int):
    name = "LS_LoopSubdiv_NoSubdivide_Repeat_5x"
    remove_node_group_if_exists(name)

    ng = bpy.data.node_groups.new(name, "GeometryNodeTree")
    add_group_socket(ng, "Geometry", "INPUT", "NodeSocketGeometry")
    add_group_socket(ng, "Iterations", "INPUT", "NodeSocketInt", default=default_iterations, min_value=0)
    add_group_socket(ng, "Geometry", "OUTPUT", "NodeSocketGeometry")

    nodes = ng.nodes
    links = ng.links
    nodes.clear()

    gin = n(ng, "NodeGroupInput")
    gout = n(ng, "NodeGroupOutput")

    # Repeat Zone nodes
    rep_in = n(ng, "GeometryNodeRepeatInput")
    rep_out = n(ng, "GeometryNodeRepeatOutput")

    # Pair them (Repeat Input -> Repeat Output)
    # The API exposes pair_with_output() on zone input nodes. (documented in API index/search snippets)
    rep_in.pair_with_output(rep_out)

    # Iterations + Geometry into repeat input
    links.new(sock_out(gin, "Iterations"), sock_in(rep_in, "Iterations"))
    links.new(sock_out(gin, "Geometry"), sock_in(rep_in, "Geometry"))

    # One-iteration group inside the zone
    step = n(ng, "GeometryNodeGroup")
    step.node_tree = iter_group

    links.new(sock_out(rep_in, "Geometry"), sock_in(step, "Geometry"))
    links.new(sock_out(step, "Geometry"), sock_in(rep_out, "Geometry"))

    # Output
    links.new(sock_out(rep_out, "Geometry"), sock_in(gout, "Geometry"))
    return ng


def ensure_modifier(obj, node_group):
    mod = obj.modifiers.get(MOD_NAME)
    if mod is None:
        mod = obj.modifiers.new(MOD_NAME, "NODES")
    mod.node_group = node_group
    return mod


# -----------------------------
# Run
# -----------------------------
ensure_object_mode()

obj = bpy.context.active_object
if not obj or obj.type != "MESH":
    raise RuntimeError("Select a mesh object first.")

template_obj = ensure_template_object()
opp_group = make_opp_vertex_group()
iter_group = make_loop_iter_group(template_obj, opp_group)
wrapper = make_repeat_wrapper(iter_group, DEFAULT_ITERATIONS)

ensure_modifier(obj, wrapper)

print(f"[OK] Added '{MOD_NAME}' (Blender 5.0+, Repeat Zone iterations) to '{obj.name}'.")
